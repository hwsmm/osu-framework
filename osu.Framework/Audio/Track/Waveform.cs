// Copyright (c) ppy Pty Ltd <contact@ppy.sh>. Licensed under the MIT Licence.
// See the LICENCE file in the repository root for full licence text.

using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using mysoundlib_cs;
using osu.Framework.Audio.Callbacks;
using osu.Framework.Extensions;
using osu.Framework.Logging;
using osu.Framework.Utils;

namespace osu.Framework.Audio.Track
{
    /// <summary>
    /// Processes audio sample data such that it can then be consumed to generate waveform plots of the audio.
    /// </summary>
    public class Waveform : IDisposable
    {
        /// <summary>
        /// <see cref="Point"/>s are initially generated to a 1ms resolution to cover most use cases.
        /// </summary>
        private const float resolution = 0.001f;

        /// <summary>
        /// FFT1024 gives ~40hz accuracy.
        /// </summary>
        private const int fft_samples = 1024;

        /// <summary>
        /// Number of bins generated by the FFT. Must correspond to <see cref="fft_samples"/>.
        /// </summary>
        private const int fft_bins = 512;

        /// <summary>
        /// Minimum frequency for low-range (bass) frequencies. Based on lower range of bass drum fallout.
        /// </summary>
        private const float low_min = 20;

        /// <summary>
        /// Minimum frequency for mid-range frequencies. Based on higher range of bass drum fallout.
        /// </summary>
        private const float mid_min = 100;

        /// <summary>
        /// Minimum frequency for high-range (treble) frequencies.
        /// </summary>
        private const float high_min = 2000;

        /// <summary>
        /// Maximum frequency for high-range (treble) frequencies. A sane value.
        /// </summary>
        private const float high_max = 12000;

        private int channels;
        private Point[] points = Array.Empty<Point>();

        private const int sample_rate = 44100;

        private readonly CancellationTokenSource cancelSource = new CancellationTokenSource();

        private readonly Task readTask;

        private Stream? data;

        /// <summary>
        /// Constructs a new <see cref="Waveform"/> from provided audio data.
        /// </summary>
        /// <param name="data">
        /// The sample data stream.
        /// The <see cref="Waveform"/> will take ownership of this stream and dispose it when done reading track data.
        /// If null, an empty waveform is constructed.
        /// </param>
        public unsafe Waveform(Stream? data)
        {
            this.data = data;

            var token = cancelSource.Token;

            readTask = Task.Run(() =>
            {
                if (data == null)
                    return;

                this.data = null;
                channels = 2;

                SDL3AudioFileCallbacks callbacks = new SDL3AudioFileCallbacks(data);
                IntPtr track = MySoundLibrary.mslCreateTrack();
                if (track == IntPtr.Zero)
                    return;

                IntPtr decoder = MySoundLibrary.mslCreateTrackDecoder(track, callbacks.Handle, callbacks.ReadCallback, callbacks.SeekCallback);
                Point[]? pointArray = null;
                int currentPoint = 0;

                try
                {
                    if (decoder != IntPtr.Zero)
                    {
                        do
                        {
                            if (MySoundLibrary.mslDecoderProcessChunk(decoder) < 0)
                                break;
                        } while (!MySoundLibrary.mslDecoderIsDone(decoder).ToBool());

                        int pointCount = fft_samples / (int)Math.Pow(2, Math.Ceiling(Math.Log2(resolution * sample_rate)));
                        float[] fft = new float[fft_bins];
                        float[] amps = new float[pointCount * 2];

                        while (true)
                        {
                            int ret;

                            fixed (float* fftPtr = fft)
                            fixed (float* ampPtr = amps)
                            {
                                if (pointArray == null)
                                {
                                    nuint pointLen = 0;
                                    ret = MySoundLibrary.mslTrackCalculateCurrent(track, 1, pointCount, fft_samples, fftPtr, ampPtr, &pointLen);
                                    pointArray = new Point[pointLen];
                                }
                                else
                                {
                                    ret = MySoundLibrary.mslTrackCalculateCurrent(track, 1, pointCount, fft_samples, fftPtr, ampPtr, null);
                                }

                                if (ret < 0)
                                {
                                    Logger.Log("Failed to generate waveform: " + ret);
                                    break;
                                }
                            }

                            float lowIntensity = 0.0f;
                            float midIntensity = 0.0f;
                            float highIntensity = 0.0f;

                            if (ret == pointCount)
                            {
                                lowIntensity = computeIntensity(sample_rate, fft, low_min, mid_min);
                                midIntensity = computeIntensity(sample_rate, fft, mid_min, high_min);
                                highIntensity = computeIntensity(sample_rate, fft, high_min, high_max);
                            }

                            for (int i = 0; i < ret; i++)
                            {
                                Point point = new Point
                                {
                                    AmplitudeLeft = amps[i * 2],
                                    AmplitudeRight = amps[i * 2 + 1],
                                    LowIntensity = lowIntensity,
                                    MidIntensity = midIntensity,
                                    HighIntensity = highIntensity
                                };

                                pointArray[currentPoint++] = point;
                            }

                            if (ret < pointCount)
                                break;
                        }
                    }
                }
                finally
                {
                    points = pointArray ?? Array.Empty<Point>();

                    MySoundLibrary.mslDestroyAudioDecoder(&decoder);
                    MySoundLibrary.mslDestroyTrack(track);
                    callbacks.Dispose();

                    data.Dispose();
                    data = null;
                }
            }, token);
        }

        private static float computeIntensity(int frequency, ReadOnlySpan<float> bins, float startFrequency, float endFrequency)
        {
            int startBin = (int)(fft_bins * 2 * startFrequency / frequency);
            int endBin = (int)(fft_bins * 2 * endFrequency / frequency);

            startBin = Math.Clamp(startBin, 0, fft_bins);
            endBin = Math.Clamp(endBin, 0, fft_bins);

            float value = 0;
            for (int i = startBin; i < endBin; i++)
                value += bins[i];
            return value;
        }

        /// <summary>
        /// Creates a new <see cref="Waveform"/> containing a specific number of data points by selecting the average value of each sampled group.
        /// </summary>
        /// <param name="pointCount">The number of points the resulting <see cref="Waveform"/> should contain.</param>
        /// <param name="cancellationToken">The token to cancel the task.</param>
        /// <returns>An async task for the generation of the <see cref="Waveform"/>.</returns>
        public async Task<Waveform> GenerateResampledAsync(int pointCount, CancellationToken cancellationToken = default)
        {
            ArgumentOutOfRangeException.ThrowIfNegative(pointCount);

            if (pointCount == 0)
                return new Waveform(null);

            await readTask.ConfigureAwait(false);

            return await Task.Run(() =>
            {
                var generatedPoints = new Point[pointCount];

                float pointsPerGeneratedPoint = (float)points.Length / pointCount;

                // Determines at which width (relative to the resolution) our smoothing filter is truncated.
                // Should not effect overall appearance much, except when the value is too small.
                // A gaussian contains almost all its mass within its first 3 standard deviations,
                // so a factor of 3 is a very good choice here.
                const int kernel_width_factor = 3;

                int kernelWidth = (int)(pointsPerGeneratedPoint * kernel_width_factor) + 1;

                float[] filter = new float[kernelWidth + 1];

                for (int i = 0; i < filter.Length; ++i)
                {
                    if (cancellationToken.IsCancellationRequested)
                        return new Waveform(null);

                    filter[i] = (float)Blur.EvalGaussian(i, pointsPerGeneratedPoint);
                }

                // we're keeping two indices: one for the original (fractional!) point we're generating based on,
                // and one (integral) for the points we're going to be generating.
                // it's important to avoid adding by pointsPerGeneratedPoint in a loop, as floating-point errors can result in
                // drifting of the computed values in either direction - we multiply the generated index by pointsPerGeneratedPoint instead.
                float originalPointIndex = 0;
                int generatedPointIndex = 0;

                while (generatedPointIndex < pointCount)
                {
                    if (cancellationToken.IsCancellationRequested)
                        return new Waveform(null);

                    int startIndex = (int)originalPointIndex - kernelWidth;
                    int endIndex = (int)originalPointIndex + kernelWidth;

                    var point = new Point();
                    float totalWeight = 0;

                    for (int j = startIndex; j < endIndex; j++)
                    {
                        if (j < 0 || j >= points.Length) continue;

                        float weight = filter[Math.Abs(j - startIndex - kernelWidth)];
                        totalWeight += weight;

                        point.AmplitudeLeft += weight * points[j].AmplitudeLeft;
                        point.AmplitudeRight += weight * points[j].AmplitudeRight;
                        point.LowIntensity += weight * points[j].LowIntensity;
                        point.MidIntensity += weight * points[j].MidIntensity;
                        point.HighIntensity += weight * points[j].HighIntensity;
                    }

                    if (totalWeight > 0)
                    {
                        // Means
                        point.AmplitudeLeft /= totalWeight;
                        point.AmplitudeRight /= totalWeight;
                        point.LowIntensity /= totalWeight;
                        point.MidIntensity /= totalWeight;
                        point.HighIntensity /= totalWeight;
                    }

                    generatedPoints[generatedPointIndex] = point;

                    generatedPointIndex += 1;
                    originalPointIndex = generatedPointIndex * pointsPerGeneratedPoint;
                }

                return new Waveform(null)
                {
                    points = generatedPoints,
                    channels = channels
                };
            }, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Gets all the points represented by this <see cref="Waveform"/>.
        /// </summary>
        public Point[] GetPoints() => GetPointsAsync().GetResultSafely();

        /// <summary>
        /// Gets all the points represented by this <see cref="Waveform"/>.
        /// </summary>
        public async Task<Point[]> GetPointsAsync()
        {
            await readTask.ConfigureAwait(false);
            return points;
        }

        /// <summary>
        /// Gets the number of channels represented by each <see cref="Point"/>.
        /// </summary>
        public int GetChannels() => GetChannelsAsync().GetResultSafely();

        /// <summary>
        /// Gets the number of channels represented by each <see cref="Point"/>.
        /// </summary>
        public async Task<int> GetChannelsAsync()
        {
            await readTask.ConfigureAwait(false);
            return channels;
        }

        #region Disposal

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private bool isDisposed;

        protected virtual void Dispose(bool disposing)
        {
            if (isDisposed)
                return;

            isDisposed = true;

            cancelSource.Cancel();
            cancelSource.Dispose();
            points = Array.Empty<Point>();

            // Try disposing the stream again in case the task was not started.
            data?.Dispose();
            data = null;
        }

        #endregion

        /// <summary>
        /// Represents a singular point of data in a <see cref="Waveform"/>.
        /// </summary>
        public struct Point
        {
            /// <summary>
            /// The amplitude of the left channel.
            /// </summary>
            public float AmplitudeLeft;

            /// <summary>
            /// The amplitude of the right channel.
            /// </summary>
            public float AmplitudeRight;

            /// <summary>
            /// Unnormalised total intensity of the low-range (bass) frequencies.
            /// </summary>
            public float LowIntensity;

            /// <summary>
            /// Unnormalised total intensity of the mid-range frequencies.
            /// </summary>
            public float MidIntensity;

            /// <summary>
            /// Unnormalised total intensity of the high-range (treble) frequencies.
            /// </summary>
            public float HighIntensity;
        }
    }
}
